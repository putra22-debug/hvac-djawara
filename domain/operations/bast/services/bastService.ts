import { createClient } from '@/lib/supabase/client';
import type { BAST, CreateBASTDto, ApproveBASTDto, RejectBASTDto } from '../types/bast.types';

export const bastService = {
  /**
   * Get BAST by service order ID
   */
  async getBASTByOrderId(serviceOrderId: string): Promise<BAST | null> {
    const supabase = createClient();
    
    const { data, error } = await supabase
      .from('bast')
      .select('*')
      .eq('service_order_id', serviceOrderId)
      .single();
    
    if (error) {
      if (error.code === 'PGRST116') return null; // No rows found
      throw error;
    }
    
    return data as BAST;
  },

  /**
   * Create BAST
   */
  async createBAST(dto: CreateBASTDto): Promise<BAST> {
    const supabase = createClient();
    
    const { data, error } = await supabase
      .from('bast')
      .insert({
        service_order_id: dto.serviceOrderId,
        spk_report_id: dto.spkReportId,
        client_name: dto.clientName,
        technician_name: dto.technicianName,
        bast_number: '', // Will be auto-generated by trigger
      })
      .select()
      .single();
    
    if (error) throw error;
    return data as BAST;
  },

  /**
   * Upload signature to storage
   */
  async uploadSignature(signatureBase64: string, fileName: string): Promise<string> {
    const supabase = createClient();
    
    // Convert base64 to blob
    const byteString = atob(signatureBase64.split(',')[1]);
    const mimeString = signatureBase64.split(',')[0].split(':')[1].split(';')[0];
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i < byteString.length; i++) {
      ia[i] = byteString.charCodeAt(i);
    }
    const blob = new Blob([ab], { type: mimeString });
    
    // Upload to storage
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');
    
    const filePath = `signatures/${user.id}/${fileName}`;
    
    const { error: uploadError } = await supabase.storage
      .from('bast')
      .upload(filePath, blob, {
        contentType: mimeString,
        upsert: true,
      });
    
    if (uploadError) throw uploadError;
    
    // Get public URL
    const { data: { publicUrl } } = supabase.storage
      .from('bast')
      .getPublicUrl(filePath);
    
    return publicUrl;
  },

  /**
   * Approve BAST with signatures
   */
  async approveBAST(id: string, dto: ApproveBASTDto): Promise<BAST> {
    const supabase = createClient();
    
    // Upload signatures
    const clientSignatureUrl = await this.uploadSignature(
      dto.clientSignature,
      `client_${id}_${Date.now()}.png`
    );
    
    const technicianSignatureUrl = await this.uploadSignature(
      dto.technicianSignature,
      `technician_${id}_${Date.now()}.png`
    );
    
    // Update BAST
    const { data, error } = await supabase
      .from('bast')
      .update({
        client_signature_url: clientSignatureUrl,
        technician_signature_url: technicianSignatureUrl,
        client_approved_at: new Date().toISOString(),
        status: 'approved',
      })
      .eq('id', id)
      .select()
      .single();
    
    if (error) throw error;

    // Update service order status to approved
    const { error: orderError } = await supabase
      .from('service_orders')
      .update({ status: 'approved' })
      .eq('id', data.service_order_id);
    
    if (orderError) throw orderError;
    
    return data as BAST;
  },

  /**
   * Reject BAST
   */
  async rejectBAST(id: string, dto: RejectBASTDto): Promise<BAST> {
    const supabase = createClient();
    
    const { data, error } = await supabase
      .from('bast')
      .update({
        status: 'rejected',
        rejection_reason: dto.rejectionReason,
      })
      .eq('id', id)
      .select()
      .single();
    
    if (error) throw error;

    // Update service order status to complaint
    const { error: orderError } = await supabase
      .from('service_orders')
      .update({ status: 'complaint' })
      .eq('id', data.service_order_id);
    
    if (orderError) throw orderError;
    
    return data as BAST;
  },
};
